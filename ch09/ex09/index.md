# SOLID 原則とは
オブジェクト指向の設計原則として従うべき5つの原則
ソフトウェアの拡張性、保守性、可読性を高めるためのもの

## 1. 単一責任の原則 (single-responsibility principle)
すべてのモジュールにおいて、それが持つ責務は1つとする

### 問題
依存関係が複雑になり、1つの役割の変更が、別の役割にも影響を与えるようになってしまう<br>
何かを変更するたびに、その影響を受けるすべてのモジュールの動作を確認しなくてはならなくなる<br>
保守性が下がり、バグを生み出しやすくなる

### メリット
- 変更箇所を最小限にできる
- 変更箇所が明確になる
- 可読性が向上する
- 他のモジュールから利用しやすくなり、拡張性が向上する

### 解決策
モジュールを機能ごとに小さく作る<br>
概念が異なるものは分ける


## 2. 開放閉鎖の原則（open/closed principle）
モジュールは、拡張に対しては開いていて、変更に対しては閉じていなければならない

拡張に対して開かれている・・・コードを追加すれば機能を追加できる<br>
変更に対して閉じている・・・機能の追加によって既存のコードは修正されない

既存のコードを変更せずに新しい機能を追加できるということ

### 問題
既存のコードの修正が必要な場合、それまで動いていたコードへ影響を与えてしまう<br>
既存のコードを修正するたび、テストが必要になる

### メリット
- 拡張が容易になる
- 拡張機能だけをテストすればよくなるので、保守性が高まる

### 解決策
拡張しうる部分は抽象化する<br>
振る舞いが異なる場合は別のクラスに分ける<br>
そして、それらが共通の抽象クラスやインターフェースを持つようにする


## 3. リスコフの置換原則（Liskov substitution principle）
サブタイプはそのスーパータイプと置換可能でなければならない

サブタイプのインスタンスは、スーパータイプのインスタンスと同じように振る舞うべきである<br>
スーパータイプの代わりにサブタイプを利用しても問題ないように作らなければならない

### 問題
サブタイプがスーパータイプと異なる挙動をすると、予期しない結果になる可能性があり、バグにつながる<br>
サブタイプがスーパータイプと異なる挙動をする場合、プログラマはサブクラスの内容をすべて理解しなければならなくなる

### メリット
- 既存のコードの修正なしに新しい機能や振る舞いを追加することができる
- サブクラスのオブジェクトをスーパークラスのオブジェクトとして自由に置換できる
- スーパータイプの仕様を理解すれば、それを継承したサブタイプを中身を確認せずに利用できる

### 解決策
サブタイプにしかないメソッドを追加しない<br>
メソッドをオーバーライドしないなら継承しない<br>
引数や戻り値の条件は同等にする<br>
予期せぬ振る舞いをしないように、インターフェースの一貫性を保つ


## 4. インターフェース分離の原則 (Interface segregation principle)
インターフェースのクライアントに、クライアントが利用しないプロパティ/メソッドへの依存を強制してはならない<br>
クライアントで一部のメソッドが未実装になる場合は、インターフェースの分離を検討すべきである

### 問題
インターフェースに変更が生じると、たとえ使っていないメソッドであっても、サブタイプで修正が必要になってしまう<br>
サブタイプが不要なメソッドでエラーを生じさせたり、何もしない実装をすると、リスコフの置換原則に違反してしまう

### メリット
- インターフェースを適切に分離することで、サブタイプで不必要/無駄なコードを実装しないようにできる
- インターフェースの変更に強くなる
- コードがシンプルになり、拡張性・可読性・保守性が高まる

### 解決策
インターフェースを適切に分離し、インターフェースの持つメソッドを必要最小限にする<br>
サブタイプでからのメソッドを実装しないようにする<br>
何でもかんでも入っているインターフェースを作らない


## 5. 依存性逆転の原則（dependency inversion principle）
上位レベルのモジュールは下位レベルのモジュールに依存してはならない。両方とも抽象に依存すべきである<br>
抽象は詳細に依存してはならない。詳細が抽象に依存すべきである

### 問題
下位モジュールの変更が上位モジュールに影響してしまう<br>
下位モジュールを開発しないと上位モジュールを開発できない<br>
処理を柔軟に変えられない

### メリット
- 下位モジュールを変更したとしても、抽象が変更されない限り、上位モジュールは影響を受けない
- 下位モジュールは抽象に依存しているため、上位モジュールの利用するモジュールを容易に切り替えられる

### 解決策
変化しやすい具象クラスを参照せず、抽象クラスやインターフェースを参照する<br>
ただし、変化しない具象や、変化しにくい具象の保持は許容してよい<br>
具象関数をオーバーライドせず、元の関数を抽象関数にして、それをオーバーライドする<br>
依存するオブジェクトを自分で生成せず、コンストラクタやセッターなどで外部から受け取るようにする
