# 問題11.11
performance.now を使ってプログラムの処理時間を測定してみよう。
`ch11/ex11/index.js` は `"Hello".length` にどれだけの時間がかかるか測定しようと実装したコードである。
コードを実行すると以下の事実に気付くだろう:

`costOfLength` が負の値を返すことがある (`"Hello".length` を実行すると時が巻き戻るのだろうか?)
`costOfLength` の引数の値を大きくすれば大きくする程結果が小さくなる (`"Hello".length` を実行すればする程速くなるのだろうか?)

どうやら何かがおかしい。どうしてこのような結果になるか調べて説明しなさい。

## 負の値になる理由

### 1. 測定誤差の影響
- `performance.now()` は高精度なタイマーだが、完全に正確ではない。
- 測定対象の処理時間が非常に短い場合、誤差によって差が負の値になることがある。
- 特に `costOfLengthPlusLoop` と `costOfLoop` の差が非常に小さいため、負の値になることがあった。

### 2. JIT最適化の影響
- JavaScriptエンジンは、繰り返し実行されるコードを最適化する。
- `"Hello".length` のように毎回同じ結果を返す処理は、ループの外に出されることがある。
- その結果、`costOfLengthPlusLoop` の中で `"Hello".length` が実行されなくなり、空ループと同じかそれ以下の時間になることがあった。

---

## 回数を増やすと速くなる理由
### 1. 最適化が進む
- `N = 1000` のような少ない回数では、JIT最適化がまだ適用されていない可能性がある。
- `N = 10000000` のように回数が多いと、最適化が完了し、処理が高速化される。
- `"Hello".length` のような処理は、ループの外に出されて実行されなくなることもある。

### 2. 同じ処理の繰り返しによる高速化
- CPUレベルでも、同じ命令の繰り返しはキャッシュや分岐予測により高速化される。
- そのため、回数が増えるほど1回あたりの処理時間が短く見えるという現象が起きる。
